# Компиляция и запуск программы на C

В этой лабораторной работе мы будем использовать программу командной строки g++ для компиляции программ на C. Самый простой способ запустить gcc следующий:

```
$ g++ program.c
```

Это компилирует program.c в исполняемый файл с именем a.out. Этот файл можно запустить с помощью следующей команды:

```
$ ./a.out
```

Исполняемый файл - a.out, почему добавляется ./? Когда вы хотите запустить исполняемый файл, вам нужно добавить путь к файлу, чтобы отличить вашу команду от такой команды, как python3, например. Точка указывает на текущую директорию. Таким образом, мы говорим, что запускаем a.out из текущей директории. Между прочим, двойные точки (..) исплользуются для именования родительской директории.

g++ имеет различные параметры командной строки, которые вам рекомендуется изучить. Особое внимание уделите параметрам `-Wall`, `-Werr`, `-O0`, `-O1`, `-O2`, `-O3` Однако в этой лабораторной работе мы будем использовать только `-o`, который используется для указания имени исполняемого файла, создаваемого gcc. Если вы не хотите, чтобы все ваши исполняемые файлы назывались a.out, вы можете использовать следующие команды, чтобы скомпилировать program.c в программу с именем program:

```
$ g++ -o program program.c
$ ./program
```

# Необязательно: локальная установка компилятора C
## Mac

Установите инструмент командной строки Xcode, запустив
```
$ xcode-select --install
```

Затем вы можете проверить, успешно ли установлен g++, запустив
```
$ g++ --version
```
## Ubuntu / Debian

Установите пакет, необходимый для сборки, запустив
```
$ sudo apt install build-essential cgdb valgrind
```

При этом будет установлено множество пакетов, таких как g++ и make, а также инструменты отладки cgdb и valgrind. Если вам интересно, вот подробное описание пакета, необходимого для сборки, начиная с Ubuntu 18.04.

## Windows

Для пользователей Windows рекомендуется использовать среду `cygwin`

# Задание 1. Условные конструкции

В этом задании мы увидим примеры условных конструкций. Поведение кода будет определятся константам времени компиляции `V0`, `V1`, `V2`, `V3`, определеяемыми как `constexpr int`.

В данном задании вам предстоит работать с кодом в файле `speciality.cpp`. Обратите внимание на четыре различных примера условных конструкций C.

Сначала скомпилируйте и запустите программу, чтобы увидеть, что она делает. Поиграйте с постоянными значениями четырех констант: от `V0` до `V3`. Посмотрите, как изменение каждого из них меняет вывод программы.

### Задача

Задайте набор констант таким образом, чтобы получить
```
Специальности ФКСИС
===================
Лучшая специальность:
Только Информатика и технологии программирования
БАТЭ чемпион!
```
Добавьте обновленный файл в свой репозиторий. На самом деле существует несколько различных комбинаций значений констант, которые могут дать такой результат. В этом упражнении перед вами стоит задача: подумать, какое минимальное количество различных значений может иметь от V0 до V3, чтобы они по-прежнему давали точно такой результат. Например, теоретический максимум - четыре, когда все они отличаются друг от друга.

Не знаете, как запустить программу? Вернитесь к введению. Скомпилируйте программу в исполняемый файл под названием `speciality`; Вы можете использовать для этого флаг -o.

# Задание 2. Дебажим!

Отладчик, как следует из названия, - это программа, которая разработана специально для того, чтобы помочь отладить программу, найти логические ошибки и ошибки в вашем коде. У разных отладчиков разные функции, но обычно все отладчики могут выполнять следующие действия:

* Установить точку останова в своей программе. Точка останова - это определенная строка в вашем коде, где вы хотите остановить выполнение программы, чтобы вы могли посмотреть, что происходит поблизости.
* Построчно исполнить код программы. Код всегда выполняется последовательно, строка за строкой, но это происходит слишком быстро, чтобы мы могли понять, какие строки вызывают ошибки. Возможность поэтапного выполнения кода позволяет вам точно определить, что именно вызывает ошибку в вашей программе.

Для этого упражнения вам будет полезна справочная карта `GDB`, которая приложена отдельным файлом. `GDB` означает `GNU De-Bugger`. Скомпилируйте `hello.cpp` с флагом `-g`:

```
$ g++ -g -o hello hello.cpp
```
Это флаг указывает, что надо сохранить информацию в исполняемой программе, чтобы gdb мог ее понять. Теперь запустим наш отладчик `(c)gdb`:

```
$ gdb hello
```

Обратите внимание на то, что делает эта команда. Вы запускаете программу `gdb` передав путь к исполняемому файлу `hello` в качестве аргумента. Не пытайтесь запустить `gdb` с исходным кодом `hello.c`. 

**Примечание.** `gdb` может не устанавливаться на компьютерах с macOS. Вы можете использовать lldb, еще один отличный отладчик. Команды немного отличаются, но есть руководства, которые помогут вам начать работу.

### Задача

Пройдите через всю программу, выполнив следующие действия:

1. Установка точки останова на функции main
2. Исполните команду `run`
3. Исполните команду `step`

Введите `help` в `gdb`, чтобы узнать команды для выполнения этих действий, или воспользуйтесь справкой.

## Примечание: cgdb против gdb

В этом упражнении мы используем `gdb` для отладки наших программ, но также стоит упомянуть `cgdb`. `cgdb` идентичен `cgdb`, за исключением того, что он предоставляет некоторые дополнительные приятные функции, которые делают его более удобным в использовании на практике.

В `cgdb` вы можете нажать `ESC`, чтобы перейти в окно кода (вверху), `i` чтобы вернуться в окно команд (внизу). В самом низу вы найдете окно команд, где вводятся команды `GDB`.

### Пункт действия

Изучение этих команд окажется полезным для остальной части этой лабораторной работы и для вашей карьеры программиста на языке C++ в целом. В текстовом файле с именем gdb.txt ответьте на следующие вопросы.

1. Когда вы находитесь в сеансе gdb, как вы устанавливаете аргументы, которые будут передаваться программе при ее запуске?
2. Как создать точку останова?
2. Как выполнить следующую строку кода C в программе после остановки в точке останова?
3. Если следующая строка кода является вызовом функции, вы выполните весь вызов функции сразу, если воспользуетесь своим ответом на # 3. (Если нет, рассмотрите другую команду для # 3!) Как вы сообщите GDB, что хотите вместо этого отладить код внутри функции (т.е. перейти внутрь функции)?
4. Как продолжить выполнение программы после остановки на точке останова?
5. Как вы можете распечатать значение переменной (или даже выражение типа 1 + 2) в gdb?
6. Как настроить gdb так, чтобы он отображал значение переменной после каждого шага?
7. Как вы показываете список всех переменных и их значений в текущей функции?
8. Как выйти из GDB?

# Задание 3. Интерактивная отладка

Давайте посмотрим, что произойдет, если ваша программа требует ввода данных пользователем, и вы попытаетесь запустить её в `GDB`. Во-первых, соберите и запустите программу, определенную в `interactive_hello.cpp`, чтобы поговорить с слишком дружелюбной программой.
```
$ g++ -g -o int_hello interactive_hello.cpp
$ ./int_hello
```
Теперь попробуем отладить его (хотя на самом деле ошибок нет).
```
$ gdb int_hello
```
Что происходит, когда вы пытаетесь запустить программу до конца исполнения? Цель этого задания - избавить вас от боязни запуска отладчика, даже если вашей программе требуется ввод данных пользователем. Оказывается, вы можете отправлять текст на стандартный ввод `stdin`, файловый поток, читаемый через объект `std::cin`, в этой глупой программе, с некоторыми специальными символами прямо из командной строки.

*Подсказка 1.* Если вы создаете текстовый файл, содержащий введенные вами данные, вы на правильном пути! 
*Подсказка 2.* Помните, что вы также можете запускать программы с аргументами командной строки (включая символы перенаправления) из `GDB`!

# Задание 4. Valgrind

Даже с отладчиком мы не сможем отловить все ошибки. Некоторые ошибки мы называем ошибки Борбагами, что означает, что они надежно проявляются при четко определенном, но, возможно, неизвестном наборе условий. Другие ошибки мы называем Гейзенбагами, и вместо того, чтобы быть четко определенными, они исчезают или изменяют свое поведение, когда их пытаются изучить. Мы можем обнаружить первый тип с помощью отладчиков, но второй тип может ускользнуть от нас, потому что они (по крайней мере, в `C/С++`) часто возникают из-за неправильного управления памятью.

Помните, что в отличие от других языков программирования, `C` требует, чтобы вы (программист) вручную управляли своей памятью.

Чтобы помочь отловить этих Гейзенбагов, мы будем использовать инструмент под названием `Valgrind`. `Valgrind` - это программа, которая имитирует ваш процессор и отслеживает обращения к вашей памяти. Это замедляет выполняемый вами процесс (поэтому мы, например, не всегда запускаем все исполняемые файлы внутри `Valgrind`), но также может выявить ошибки, которые могут отображать только видимое неправильное поведение при уникальном стечении обстоятельств.

*Примечание.* `Valgrind` доступен для установки в большинстве Unix-подобных дистрибутивов, а также в macOS, однако возможны проблемы совместимости между `Valgrind` и последними версиями macOS. Если у вас не получается запустисть `Valgrind` из `homebrew`, придется собрать вручную на своей машине следую инструкциям.

В этом упражнении мы продемонстрируем два разных примера выходных данных `Valgrind` и рассмотрим, как каждый из них может быть полезен.

Сначала создайте два новых исполняемых файла, `segfault_ex` из `segfault_ex.cpp` и `no_segfault_ex` из `no_segfault_ex.cpp` (используйте флаг `-o`). На этом этапе вы сможете использовать `g++` для успешной сборки этих исполняемых файлов.

Теперь попробуем запустить исполняемые файлы. Какие результаты вы наблюдаете?

Начнем с `segfault_ex`. Вы должны были наблюдать ошибку сегментации (`segfault`), которая возникает, когда программа вылетает из-за попытки получить доступ к памяти, которая ей недоступна (подробнее об этом вы узнаете позже в курсе; на самом деле это артефакт из раннего проектирования памяти. Сегодня мы работаем с «выгружаемой памятью» вместо «сегментированной памяти», но сообщение об ошибке осталось).

Этот файл исходный код очень мал, поэтому вы должны иметь возможность открыть файл и понять, что вызывает `segfault`. Сделайте это сейчас, но не меняйте файл. Почему возникает `segfault`?

Теперь давайте разберемся, что делать, если у нас очень большой файл и нужно найти `segfault`. Вот где нам поможет `Valgrind`. Для запуска программы в `Valgrind` используйте команду:

```
$ valgrind ./segfault_ex
```
Это должно привести к тому, что `Valgrind` выведет информацию о том, где произошел незаконный доступ. Сравните эти результаты с вашими предположениями. Как `Valgrind` может помочь вам устранить ошибку сегментации в будущем?

Теперь попробуйте запустить `Valgrind` на `no_segfault_ex`. Программа не должна была дать сбой, но проблема с файлом все еще существует. `Valgrind` может помочь нам найти (на первый взгляд невидимую) проблему.

К сожалению, здесь вы увидите, что `Valgrind`, похоже, не может сказать вам, где именно возникает проблема. Используйте сообщение, предоставленное `Valgrind`, чтобы определить, какая переменная вызывает некорректное поведение, а затем попытайтесь сделать вывод, что должно было произойти (Подсказка: что такое неинициализированное значение?).

Надеюсь, пройдя этот пример, вы сможете понять и ответить на следующие вопросы:

1. Почему важен `Valgrind` и чем он полезен?
2. Как запустить программу в `Valgrind`?
3. Как вы интерпретируете сообщения об ошибках?
4. Почему неинициализированные переменные могут приводить к появлению Гейзенбагов?

`Valgrind` чрезвычайно важный инструмент, который вам понадобится, как только вы начнете писать на C++. Будьте готовы ответить на следующие вопросы:

1. Почему не произошел segfault программы no_segfault_ex?
2. Почему no_segfault_ex выдает несогласованные выходные данные?
3. Почему указан неправильный размер? Как можно было исправить код используя sizeof?

### Задача

Исправьте ошибки с помощью Valgrind

# Задание 5. Указатели и структуры.

Одна из задач, которая поможет вам на собеседовании. Сам решал такую задачу на собеседовании в Яндекс)). В `ll_cycle.cpp` завершите функцию `ll_has_cycle()`, чтобы реализовать следующий алгоритм проверки наличия цикла в односвязном списке.

1. Начните с двух указателей в начале списка. Первого назовем черепахой, а вторую зайцем.
2. Продвинуть зайца на два узла. Если это невозможно из-за нулевого указателя, значит, мы нашли конец списка, поэтому список ациклический.
3. Продвинуть черепаху на один узел. (Проверка нулевого указателя не требуется. Почему?)
4. Если черепаха и заяц указывают на один и тот же узел, список циклический. В противном случае вернитесь к шагу 2.

Если вы хотите увидеть определение структуры узла, откройте файл заголовка `ll_cycle.h`.

### Задача

Реализуйте `ll_has_cycle()`. Как только вы это сделаете, вы можете выполнить следующие команды, чтобы запустить тесты для вашего кода. Если вы вносите какие-либо изменения, обязательно снова выполните ВСЕ следующие команды по порядку.

```
$ g++ -g -o test_ll_cycle test_ll_cycle.cpp ll_cycle.cpp
$ ./test_ll_cycle
```

*Подсказка.* Эту функцию можно реализовать двумя способами. Они различаются тем, как кодируется критерий остановки. Если вы сделаете это одним способом, вначале вам придется учитывать особый случай. Если вы сделаете это по-другому, у вас будет несколько дополнительных проверок NULL, и это нормально. Предыдущие два предложения призваны убедить вас не беспокоиться о чистоте. Если они вам не помогают, просто игнорируйте их. Цель этого упражнения - убедиться, что вы знаете, как использовать указатели. 


# Задание 6. Makefile. Собираем проще.

Как вы уже могли заметить, компиляция программ C в терминале - утомительная и трудоемкая операция, требующая выполнения нескольких команд с большим количеством аргументов. Хотя это возможно для простых программ, для более крупных и сложных программ с десятками файлов и зависимостей это быстро становится довольно неудобным.

Для сборки больших и сложных обычно используется так называемый «make-файл», который облегчает компиляцию. `Makefile` - это текстовый файл (буквально названный `Makefile`) в каталоге кода, который содержит набор правил, каждое из которых имеет команды, компилирующие для них С/С++ программу. Каждый make-файл может содержать несколько правил, каждое из которых компилирует одну или несколько целей, исполняемый файл или библиотеку, или выполняет другую задачу. Чтобы скомпилировать цель, программисту просто нужно ввести `make` в командный терминал.

### Задача

Взгляните на `Makefile`, включенный в эту лабораторную работу, и попытайтесь ответить на следующие вопросы в `make.txt`. Обязательно используйте Интернет, чтобы выяснить некоторые из этих вопросов, но ответы пишите своими словами, как вы сами понимаете.

1. Какая цель является частью правила, удаляющего все скомпилированные программы?
2. Какая цель является частью правила, которое создает все скомпилированные программы?
3. Какой компилятор сейчас используется?
4. Какой стандарт C мы используем в настоящее время?
5. Как мы можем ссылаться на переменную «FOO» в make-файле?
6. Для чего используется переменная `CFLAGS`?
7. Какая строка создает программу lfsr из ее объектных файлов? (Укажите номер строки.)

На самом деле, для серьезных проектов даже make-файлы оказываются слишком сложными и трудночитаемыми. Поэтому разработаны другие системы сборки проектов, такие как `cmake`.

# Задание 7: Битовые операции

В этом упражнении вы завершите `bit_ops.cpp`, реализовав функции манипулирования битами `get_bit`, `set_bit` и `flip_bit`, которые предствалены ниже. Вы можете использовать ТОЛЬКО побитовые операции, такие как И `&`, ИЛИ `|`, XOR `^`, НЕ `~`, сдвиг влево `<<` и сдвиг вправо `>>`. Вы не можете использовать циклы `for / while` или условные операторы. Вы также не можете использовать деление по модулю, деление, сложение, вычитание или умножение в этом задании.
```
// Возвращает бит номер n числа x.
// Предполагается 0 <= n <= 31
unsigned get_bit(unsigned x, unsigned n);

// Выставляет значение v в бите номер n
// Предполагается что 0 <= n <= 31 и v равно 0 или 1
void set_bit(unsigned * x, unsigned n, unsigned v);

// Меняет значение бита номер n на противоположное.
// Предполагается что 0 <= n <= 31
void flip_bit(unsigned * x, unsigned n);
```
### Задача: Завершите реализацию `get_bit`, `set_bit` и `flip_bit`.

Выполнив эти функции, вы можете скомпилировать и запустить свой код с помощью следующих команд:
```
$ make bit_ops
$ ./bit_ops
```
Это распечатает результат выполнения тестов. Очевидно, все тесты должны проходить успешно.


# Задание 8. Регистр сдвига с линейной обратной связью

В этом упражнении вы реализуете функцию `lfsr_calculate()` для вычисления следующей итерации регистра сдвига с линейной обратной связью (inear feedback shift register, LFSR). Приложения, использующие LFSR: цифровое телевидение, мобильные телефоны CDMA, Ethernet, USB 3.0 и другие! Эта функция будет генерировать псевдослучайные числа с помощью побитовых операторов. Дополнительные сведения см. В статье в [Википедии о регистрах сдвига с линейной обратной связью](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D1%81%D0%B4%D0%B2%D0%B8%D0%B3%D0%B0_%D1%81_%D0%BB%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%BE%D0%B9_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B9_%D1%81%D0%B2%D1%8F%D0%B7%D1%8C%D1%8E). В `lfsr.cpp` заполните функцию `lfsr_calculate()`, чтобы она реализовывала следующую логику:

#### Принципиальная схема
![Схема LFSR](LFSR-F18.png)

Объяснение

* При каждом вызове `lfsr_calculate` вы будете сдвигать содержимое регистра на 1 бит вправо.
* Этот сдвиг не является ни логическим, ни арифметическим. С левой стороны вы сдвинетесь на один бит, равный ИСКЛЮЧАЮЩЕМУ ИЛИ (XOR) битов, изначально находящихся в позиции 0, 2, 3 и 5.
* Объект в форме изогнутого головного фонаря - это XOR, который принимает два входа (a, b) и выводит a ^ b.
* Если вы реализовали `lfsr_calculate()` правильно, он должен вывести все 65535 положительных 16-битных целых чисел перед циклическим возвратом к начальному числу.
* Обратите внимание, что крайний левый бит - это старший бит, а крайний правый бит - это младший бит.

### Задача
 
Реализуйте `lfsr_calculate()`, скомпилируйте `lfsr` и запустите его. Убедитесь, что результат выглядит следующим образом:

```
$ make lfsr
$ ./lfsr
Мое число: 1
Мое число: 5185
Мое число: 38801
Мое число: 52819
Мой число: 21116
Мой число: 54726
Мой число: 26552
Мой число: 46916
Мой число: 41728
Мой число: 26004
Мой число: 62850
Мой число: 40625
Мой число: 647
Мой число: 12837
Мой число: 7043
Мой число: 26003
Мой число: 35845
Мой число: 61398
Мой число: 42863
Мой число: 57133
Мой число: 59156
Мой число: 13312
Мой число: 16285
 ... и так далее, и тому подобное ... 
Получилось 65535 чисел до выхода
Поздравляем! Оно работает! 
```
# Материалы, которые следует изучить к сдаче.
К сдаче настоятельно рекомендуется изучить Главу 3 из учебника "Архитектура компьютера". Необходимо понимать, как работают базовые логическией элементы и уметь составлять пройстейшие цифровые схемы.

